# ===----------------------------------------------------------------------=== #
#
# This file is Modular Inc proprietary.
#
# ===----------------------------------------------------------------------=== #
# RUN: %mojo -debug-level full -I %S/.. %s | FileCheck %s

from math import max, min

from GatherScatter import scatter_nd_generator
from runtime.llcl import OutputChainPtr, OwningOutputChainPtr, Runtime
from tensor import Tensor, TensorShape
from test_utils import linear_fill


fn test_case[
    type: DType,
](
    input_shape: TensorShape,
    indices_shape: TensorShape,
    updates_shape: TensorShape,
    data_vals: VariadicList[SIMD[type, 1]],
    indices_vals: VariadicList[SIMD[DType.int64, 1]],
    updates_vals: VariadicList[SIMD[type, 1]],
    output_ref_vals: VariadicList[SIMD[type, 1]],
):
    @always_inline
    @parameter
    fn use_update[
        _type: DType, width: Int
    ](input_val: SIMD[_type, width], update_val: SIMD[_type, width]) -> SIMD[
        _type, width
    ]:
        return update_val

    test_case[type, use_update](
        input_shape,
        indices_shape,
        updates_shape,
        data_vals,
        indices_vals,
        updates_vals,
        output_ref_vals,
    )


fn test_case[
    type: DType,
    reduce_fn: fn[type: DType, width: Int] (
        SIMD[type, width], SIMD[type, width]
    ) capturing -> SIMD[type, width],
](
    input_shape: TensorShape,
    indices_shape: TensorShape,
    updates_shape: TensorShape,
    data_vals: VariadicList[SIMD[type, 1]],
    indices_vals: VariadicList[SIMD[DType.int64, 1]],
    updates_vals: VariadicList[SIMD[type, 1]],
    output_ref_vals: VariadicList[SIMD[type, 1]],
):
    let data = Tensor[type](input_shape)
    linear_fill(data, data_vals)
    let indices = Tensor[DType.int64](indices_shape)
    linear_fill(indices, indices_vals)
    let updates = Tensor[type](updates_shape)
    linear_fill(updates, updates_vals)
    let output = Tensor[type](input_shape)

    # Note: This is for the specific set of examples
    #      (due to _to_ndbuffer[] parameters).
    # last example 3,2,2,3 ; original: 3,2,3,3
    with Runtime() as rt:
        let out_chain = OwningOutputChainPtr(rt)
        scatter_nd_generator[reduce_fn, type, DType.int64, 3, 2, 3, False](
            data._to_ndbuffer[3](),
            indices._to_ndbuffer[2](),
            updates._to_ndbuffer[3](),
            output._to_ndbuffer[3](),
            out_chain.borrow(),
        )
        out_chain.wait()

    _ = data
    _ = indices
    _ = updates

    let output_ref = Tensor[type](input_shape)
    linear_fill(output_ref, output_ref_vals)

    for i in range(output.num_elements()):
        if output_ref._to_buffer()[i] != output._to_buffer()[i]:
            print_no_newline("FAIL: Mismatch at idx: ")
            print(i)


fn main():
    fn test_scatternd():
        print("== test_scatternd")
        let data = VariadicList[Float32](
            1,
            2,
            3,
            4,
            5,
            6,
            7,
            8,
            8,
            7,
            6,
            5,
            4,
            3,
            2,
            1,
            1,
            2,
            3,
            4,
            5,
            6,
            7,
            8,
            8,
            7,
            6,
            5,
            4,
            3,
            2,
            1,
            8,
            7,
            6,
            5,
            4,
            3,
            2,
            1,
            1,
            2,
            3,
            4,
            5,
            6,
            7,
            8,
            8,
            7,
            6,
            5,
            4,
            3,
            2,
            1,
            1,
            2,
            3,
            4,
            5,
            6,
            7,
            8,
        )

        let indices = VariadicList[Int64](0, 2)

        let updates = VariadicList[Float32](
            5,
            5,
            5,
            5,
            6,
            6,
            6,
            6,
            7,
            7,
            7,
            7,
            8,
            8,
            8,
            8,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            2,
            3,
            3,
            3,
            3,
            4,
            4,
            4,
            4,
        )

        let output_ref = VariadicList[Float32](
            5,
            5,
            5,
            5,
            6,
            6,
            6,
            6,
            7,
            7,
            7,
            7,
            8,
            8,
            8,
            8,
            1,
            2,
            3,
            4,
            5,
            6,
            7,
            8,
            8,
            7,
            6,
            5,
            4,
            3,
            2,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            2,
            3,
            3,
            3,
            3,
            4,
            4,
            4,
            4,
            8,
            7,
            6,
            5,
            4,
            3,
            2,
            1,
            1,
            2,
            3,
            4,
            5,
            6,
            7,
            8,
        )

        test_case[DType.float32](
            TensorShape(4, 4, 4),
            TensorShape(2, 1),
            TensorShape(2, 4, 4),
            data,
            indices,
            updates,
            output_ref,
        )

    # CHECK-LABEL: test_scatternd
    # CHECK-NOT: FAIL
    test_scatternd()

    fn test_scatternd_add():
        print("== test_scatternd_add")
        let data = VariadicList[Float32](
            1,
            2,
            3,
            4,
            5,
            6,
            7,
            8,
            8,
            7,
            6,
            5,
            4,
            3,
            2,
            1,
            1,
            2,
            3,
            4,
            5,
            6,
            7,
            8,
            8,
            7,
            6,
            5,
            4,
            3,
            2,
            1,
            8,
            7,
            6,
            5,
            4,
            3,
            2,
            1,
            1,
            2,
            3,
            4,
            5,
            6,
            7,
            8,
            8,
            7,
            6,
            5,
            4,
            3,
            2,
            1,
            1,
            2,
            3,
            4,
            5,
            6,
            7,
            8,
        )

        let indices = VariadicList[Int64](0, 0)

        let updates = VariadicList[Float32](
            5,
            5,
            5,
            5,
            6,
            6,
            6,
            6,
            7,
            7,
            7,
            7,
            8,
            8,
            8,
            8,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            2,
            3,
            3,
            3,
            3,
            4,
            4,
            4,
            4,
        )

        let output_ref = VariadicList[Float32](
            7,
            8,
            9,
            10,
            13,
            14,
            15,
            16,
            18,
            17,
            16,
            15,
            16,
            15,
            14,
            13,
            1,
            2,
            3,
            4,
            5,
            6,
            7,
            8,
            8,
            7,
            6,
            5,
            4,
            3,
            2,
            1,
            8,
            7,
            6,
            5,
            4,
            3,
            2,
            1,
            1,
            2,
            3,
            4,
            5,
            6,
            7,
            8,
            8,
            7,
            6,
            5,
            4,
            3,
            2,
            1,
            1,
            2,
            3,
            4,
            5,
            6,
            7,
            8,
        )

        @always_inline
        fn _add[
            ty: DType, width: Int
        ](v1: SIMD[ty, width], v2: SIMD[ty, width]) -> SIMD[ty, width]:
            return v1 + v2

        test_case[DType.float32, _add](
            TensorShape(4, 4, 4),
            TensorShape(2, 1),
            TensorShape(2, 4, 4),
            data,
            indices,
            updates,
            output_ref,
        )

    # CHECK-LABEL: test_scatternd_add
    # CHECK-NOT: FAIL
    test_scatternd_add()

    fn test_scatternd_max():
        print("== test_scatternd_max")
        let data = VariadicList[Float32](
            1,
            2,
            3,
            4,
            5,
            6,
            7,
            8,
            8,
            7,
            6,
            5,
            4,
            3,
            2,
            1,
            1,
            2,
            3,
            4,
            5,
            6,
            7,
            8,
            8,
            7,
            6,
            5,
            4,
            3,
            2,
            1,
            8,
            7,
            6,
            5,
            4,
            3,
            2,
            1,
            1,
            2,
            3,
            4,
            5,
            6,
            7,
            8,
            8,
            7,
            6,
            5,
            4,
            3,
            2,
            1,
            1,
            2,
            3,
            4,
            5,
            6,
            7,
            8,
        )

        let indices = VariadicList[Int64](0, 0)

        let updates = VariadicList[Float32](
            5,
            5,
            5,
            5,
            6,
            6,
            6,
            6,
            7,
            7,
            7,
            7,
            8,
            8,
            8,
            8,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            2,
            3,
            3,
            3,
            3,
            4,
            4,
            4,
            4,
        )

        let output_ref = VariadicList[Float32](
            5,
            5,
            5,
            5,
            6,
            6,
            7,
            8,
            8,
            7,
            7,
            7,
            8,
            8,
            8,
            8,
            1,
            2,
            3,
            4,
            5,
            6,
            7,
            8,
            8,
            7,
            6,
            5,
            4,
            3,
            2,
            1,
            8,
            7,
            6,
            5,
            4,
            3,
            2,
            1,
            1,
            2,
            3,
            4,
            5,
            6,
            7,
            8,
            8,
            7,
            6,
            5,
            4,
            3,
            2,
            1,
            1,
            2,
            3,
            4,
            5,
            6,
            7,
            8,
        )

        @always_inline
        fn _max[
            ty: DType, width: Int
        ](v1: SIMD[ty, width], v2: SIMD[ty, width]) -> SIMD[ty, width]:
            return max(v1, v2)

        test_case[DType.float32, _max](
            TensorShape(4, 4, 4),
            TensorShape(2, 1),
            TensorShape(2, 4, 4),
            data,
            indices,
            updates,
            output_ref,
        )

    # CHECK-LABEL: test_scatternd_max
    # CHECK-NOT: FAIL
    test_scatternd_max()

    fn test_scatternd_min():
        print("== test_scatternd_min")
        let data = VariadicList[Float32](
            1,
            2,
            3,
            4,
            5,
            6,
            7,
            8,
            8,
            7,
            6,
            5,
            4,
            3,
            2,
            1,
            1,
            2,
            3,
            4,
            5,
            6,
            7,
            8,
            8,
            7,
            6,
            5,
            4,
            3,
            2,
            1,
            8,
            7,
            6,
            5,
            4,
            3,
            2,
            1,
            1,
            2,
            3,
            4,
            5,
            6,
            7,
            8,
            8,
            7,
            6,
            5,
            4,
            3,
            2,
            1,
            1,
            2,
            3,
            4,
            5,
            6,
            7,
            8,
        )

        let indices = VariadicList[Int64](0, 0)

        let updates = VariadicList[Float32](
            5,
            5,
            5,
            5,
            6,
            6,
            6,
            6,
            7,
            7,
            7,
            7,
            8,
            8,
            8,
            8,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            2,
            3,
            3,
            3,
            3,
            4,
            4,
            4,
            4,
        )

        let output_ref = VariadicList[Float32](
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            2,
            3,
            3,
            3,
            3,
            4,
            3,
            2,
            1,
            1,
            2,
            3,
            4,
            5,
            6,
            7,
            8,
            8,
            7,
            6,
            5,
            4,
            3,
            2,
            1,
            8,
            7,
            6,
            5,
            4,
            3,
            2,
            1,
            1,
            2,
            3,
            4,
            5,
            6,
            7,
            8,
            8,
            7,
            6,
            5,
            4,
            3,
            2,
            1,
            1,
            2,
            3,
            4,
            5,
            6,
            7,
            8,
        )

        @always_inline
        fn _min[
            ty: DType, width: Int
        ](v1: SIMD[ty, width], v2: SIMD[ty, width]) -> SIMD[ty, width]:
            return min(v1, v2)

        test_case[DType.float32, _min](
            TensorShape(4, 4, 4),
            TensorShape(2, 1),
            TensorShape(2, 4, 4),
            data,
            indices,
            updates,
            output_ref,
        )

    # CHECK-LABEL: test_scatternd_min
    # CHECK-NOT: FAIL
    test_scatternd_min()

    fn test_scatternd_multiply():
        print("== test_scatternd_multiply")
        let data = VariadicList[Float32](
            1,
            2,
            3,
            4,
            5,
            6,
            7,
            8,
            8,
            7,
            6,
            5,
            4,
            3,
            2,
            1,
            1,
            2,
            3,
            4,
            5,
            6,
            7,
            8,
            8,
            7,
            6,
            5,
            4,
            3,
            2,
            1,
            8,
            7,
            6,
            5,
            4,
            3,
            2,
            1,
            1,
            2,
            3,
            4,
            5,
            6,
            7,
            8,
            8,
            7,
            6,
            5,
            4,
            3,
            2,
            1,
            1,
            2,
            3,
            4,
            5,
            6,
            7,
            8,
        )

        let indices = VariadicList[Int64](0, 0)

        let updates = VariadicList[Float32](
            5,
            5,
            5,
            5,
            6,
            6,
            6,
            6,
            7,
            7,
            7,
            7,
            8,
            8,
            8,
            8,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            2,
            3,
            3,
            3,
            3,
            4,
            4,
            4,
            4,
        )

        let output_ref = VariadicList[Float32](
            5,
            10,
            15,
            20,
            60,
            72,
            84,
            96,
            168,
            147,
            126,
            105,
            128,
            96,
            64,
            32,
            1,
            2,
            3,
            4,
            5,
            6,
            7,
            8,
            8,
            7,
            6,
            5,
            4,
            3,
            2,
            1,
            8,
            7,
            6,
            5,
            4,
            3,
            2,
            1,
            1,
            2,
            3,
            4,
            5,
            6,
            7,
            8,
            8,
            7,
            6,
            5,
            4,
            3,
            2,
            1,
            1,
            2,
            3,
            4,
            5,
            6,
            7,
            8,
        )

        @always_inline
        fn _mul[
            ty: DType, width: Int
        ](v1: SIMD[ty, width], v2: SIMD[ty, width]) -> SIMD[ty, width]:
            return v1 * v2

        test_case[DType.float32, _mul](
            TensorShape(4, 4, 4),
            TensorShape(2, 1),
            TensorShape(2, 4, 4),
            data,
            indices,
            updates,
            output_ref,
        )

    # CHECK-LABEL: test_scatternd_multiply
    # CHECK-NOT: FAIL
    test_scatternd_multiply()
