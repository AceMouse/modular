# ===----------------------------------------------------------------------=== #
#
# This file is Modular Inc proprietary.
#
# ===----------------------------------------------------------------------=== #
"""Implements CUDA compilation operations."""

from utils._reflection import get_linkage_name

# ===----------------------------------------------------------------------===#
# Compilation
# ===----------------------------------------------------------------------===#


@always_inline
fn _get_nvptx_target() -> __mlir_type.`!kgen.target`:
    return __mlir_attr[
        `#kgen.target<triple = "nvptx64-nvidia-cuda", `,
        `arch = "sm_80", `,
        `features = "+ptx81", `,
        `data_layout = "e-i64:64-i128:128-v16:16-v32:32-n16:32:64",`,
        `simd_bit_width = 128> : !kgen.target`,
    ]


@value
@register_passable("trivial")
struct _CompiledClosureImpl:
    """A compiled closure implementation.

    This struct matches the type of the compiled closure type generated by
    `compile_assembly`.
    """

    var asm: __mlir_type.`!kgen.string`
    var num_captures: __mlir_type.index
    var populate: fn (__mlir_type.`!kgen.pointer<none>`) capturing -> None


@value
@register_passable("trivial")
struct _CompiledClosure:
    var asm: StringLiteral
    var num_captures: Int
    var populate: fn (Pointer[NoneType]) capturing -> None


alias _EMISSION_KIND_ASM: __mlir_type.index = (0).__as_mlir_index()
alias _EMISSION_KIND_LLVM: __mlir_type.index = (1).__as_mlir_index()


@always_inline
fn __compile_code_asm_impl[
    func_type: AnyRegType,
    func: func_type,
    /,
    target: __mlir_type.`!kgen.target` = _get_nvptx_target(),
]() -> _CompiledClosure:
    alias impl = __mlir_attr[
        `#kgen.param.expr<compile_assembly,`,
        target,
        `, `,
        _EMISSION_KIND_ASM,
        `, `,
        func,
        `> : `,
        _CompiledClosureImpl,
    ]
    alias result = _CompiledClosure(
        impl.asm,
        impl.num_captures,
        rebind[fn (Pointer[NoneType]) capturing -> None](impl.populate),
    )
    return result


@always_inline
fn __compile_code_llvm_impl[
    func_type: AnyRegType,
    func: func_type,
    /,
    target: __mlir_type.`!kgen.target` = _get_nvptx_target(),
]() -> _CompiledClosure:
    alias impl = __mlir_attr[
        `#kgen.param.expr<compile_assembly,`,
        target,
        `,`,
        _EMISSION_KIND_LLVM,
        `,`,
        func,
        `> : `,
        _CompiledClosureImpl,
    ]
    alias result = _CompiledClosure(
        impl.asm,
        impl.num_captures,
        rebind[fn (Pointer[NoneType]) capturing -> None](impl.populate),
    )
    return result


@always_inline
fn _compile_code[
    func_type: AnyRegType,
    func: func_type,
    /,
    *,
    emission_kind: StringLiteral = "asm",
    target: __mlir_type.`!kgen.target` = _get_nvptx_target(),
]() -> _CompiledClosure:
    @parameter
    if emission_kind == "llvm":
        return __compile_code_llvm_impl[func_type, func, target=target]()
    else:
        return __compile_code_asm_impl[func_type, func, target=target]()


fn _get_nvptx_fn_name[
    func_type: AnyRegType, func: func_type
]() -> StringLiteral:
    return get_linkage_name[_get_nvptx_target(), func_type, func]()
