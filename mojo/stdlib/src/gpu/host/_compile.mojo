# ===----------------------------------------------------------------------=== #
#
# This file is Modular Inc proprietary.
#
# ===----------------------------------------------------------------------=== #
"""Implements CUDA compilation operations."""

from utils._reflection import get_linkage_name

# ===----------------------------------------------------------------------===#
# Compilation
# ===----------------------------------------------------------------------===#


@always_inline
fn _get_nvptx_target() -> __mlir_type.`!kgen.target`:
    return __mlir_attr[
        `#kgen.target<triple = "nvptx64-nvidia-cuda", `,
        `arch = "sm_80", `,
        `features = "+ptx81", `,
        `data_layout = "e-i64:64-i128:128-v16:16-v32:32-n16:32:64",`,
        `simd_bit_width = 128> : !kgen.target`,
    ]


@value
@register_passable("trivial")
struct _CompiledClosureImpl:
    """A compiled closure implementation.

    This struct matches the type of the compiled closure type generated by
    `compile_assembly`.
    """

    var asm: __mlir_type.`!kgen.string`
    var num_captures: __mlir_type.index
    var populate: fn (
        __mlir_type.`!kgen.pointer<pointer<none>>`
    ) capturing -> None


@value
@register_passable("trivial")
struct _CompiledClosure:
    var asm: StringLiteral
    var num_captures: Int
    var populate: fn (Pointer[Pointer[NoneType]]) capturing -> None


alias _EMISSION_KIND_ASM: __mlir_type.index = (0).__as_mlir_index()
alias _EMISSION_KIND_LLVM: __mlir_type.index = (1).__as_mlir_index()


@always_inline
fn __compile_nvptx_asm_impl[
    func_type: AnyRegType, func: func_type->closure: _CompiledClosure
]():
    alias impl = __mlir_attr[
        `#kgen.param.expr<compile_assembly,`,
        _get_nvptx_target(),
        `, `,
        _EMISSION_KIND_ASM,
        `, `,
        func,
        `> : `,
        _CompiledClosureImpl,
    ]
    param_return[
        _CompiledClosure(
            impl.asm,
            impl.num_captures,
            rebind[fn (Pointer[Pointer[NoneType]]) capturing -> None](
                impl.populate
            ),
        )
    ]


@always_inline
fn __compile_nvptx_llvm_impl[
    func_type: AnyRegType, func: func_type->closure: _CompiledClosure
]():
    alias impl = __mlir_attr[
        `#kgen.param.expr<compile_assembly,`,
        _get_nvptx_target(),
        `,`,
        _EMISSION_KIND_LLVM,
        `,`,
        func,
        `> : `,
        _CompiledClosureImpl,
    ]
    param_return[
        _CompiledClosure(
            impl.asm,
            impl.num_captures,
            rebind[fn (Pointer[Pointer[NoneType]]) capturing -> None](
                impl.populate
            ),
        )
    ]


@always_inline
fn _compile_nvptx[
    func_type: AnyRegType,
    func: func_type,
    /,
    emission_kind: StringLiteral = "asm",
]() -> _CompiledClosure:
    @parameter
    if emission_kind == "llvm":
        alias llvm_closure: _CompiledClosure
        __compile_nvptx_llvm_impl[func_type, func -> llvm_closure]()
        return llvm_closure
    else:
        alias asm_closure: _CompiledClosure
        __compile_nvptx_asm_impl[func_type, func -> asm_closure]()
        return asm_closure


fn _get_nvptx_fn_name[
    func_type: AnyRegType, func: func_type
]() -> StringLiteral:
    return get_linkage_name[_get_nvptx_target(), func_type, func]()
