# ===----------------------------------------------------------------------=== #
#
# This file is Modular Inc proprietary.
#
# ===----------------------------------------------------------------------=== #
"""This module includes utilities for looking into the assembly of a specific
function. This is very useful for kernel engineers that do not want to look
at an entire file's assembly nor do they want to invoke the kgen tool manually.
"""

from sys.info import _current_target

from memory import UnsafePointer
from .reflection import get_linkage_name

# ===----------------------------------------------------------------------===#
# compile_info
# ===----------------------------------------------------------------------===#


@value
@register_passable("trivial")
struct _Info:
    """A compiled closure implementation.

    This struct matches the type of the compiled closure type generated by
    `compile_assembly`.
    """

    var asm: __mlir_type.`!kgen.string`
    var num_captures: __mlir_type.index
    var populate: fn (__mlir_type.`!kgen.pointer<none>`) capturing -> None


@value
@register_passable("trivial")
struct Info:
    var asm: StringLiteral
    var function_name: StringLiteral
    var num_captures: Int
    var populate: fn (UnsafePointer[NoneType]) capturing -> None
    var error_msg: StringLiteral
    var is_error: Bool

    # FIXME(MOCO-1005): This explicitly returns Self to workaround an
    # interpreter problem.
    fn __init__(
        asm: StringLiteral,
        function_name: StringLiteral,
        num_captures: Int,
        populate: fn (UnsafePointer[NoneType]) capturing -> None,
        error_msg: StringLiteral,
        is_error: Bool,
    ) -> Self:
        return Self {
            asm: asm,
            function_name: function_name,
            num_captures: num_captures,
            populate: populate,
            error_msg: error_msg,
            is_error: is_error,
        }


alias _EMISSION_KIND_ASM: __mlir_type.index = (0).__as_mlir_index()
alias _EMISSION_KIND_LLVM: __mlir_type.index = (1).__as_mlir_index()


fn _noop_populate(ptr: UnsafePointer[NoneType]) capturing:
    return


@always_inline
fn _compile_info_asm_failable_impl[
    func_type: AnyTrivialRegType,
    func: func_type,
    /,
    target: __mlir_type.`!kgen.target` = _current_target(),
]() -> Info:
    alias impl = __mlir_attr[
        `#kgen.param.expr<compile_assembly,`,
        target,
        `,`,
        _EMISSION_KIND_ASM,
        `,`,
        True.__mlir_i1__(),
        `,`,
        func,
        `> : `,
        _Info,
    ]

    @parameter
    if Int(impl.num_captures) == -1:
        alias result = Info("", "", 0, _noop_populate, impl.asm, True)
        return result
    alias result = Info(
        impl.asm,
        get_linkage_name[target, func](),
        impl.num_captures,
        rebind[fn (UnsafePointer[NoneType]) capturing -> None](impl.populate),
        "",
        False,
    )
    return result


@always_inline
fn _compile_info_asm_non_failable_impl[
    func_type: AnyTrivialRegType,
    func: func_type,
    /,
    target: __mlir_type.`!kgen.target` = _current_target(),
]() -> Info:
    alias cls = __mlir_attr[
        `#kgen.param.expr<compile_assembly,`,
        target,
        `,`,
        _EMISSION_KIND_ASM,
        `,`,
        False.__mlir_i1__(),
        `,`,
        func,
        `> : `,
        _Info,
    ]

    constrained[Int(cls.num_captures) != -1, "failed to compile code"]()

    alias result = Info(
        cls.asm,
        get_linkage_name[target, func](),
        cls.num_captures,
        rebind[fn (UnsafePointer[NoneType]) capturing -> None](cls.populate),
        "",
        False,
    )
    return result


@always_inline
fn _compile_info_llvm_failable_impl[
    func_type: AnyTrivialRegType,
    func: func_type,
    /,
    target: __mlir_type.`!kgen.target` = _current_target(),
]() -> Info:
    alias impl = __mlir_attr[
        `#kgen.param.expr<compile_assembly,`,
        target,
        `,`,
        _EMISSION_KIND_LLVM,
        `,`,
        True.__mlir_i1__(),
        `,`,
        func,
        `> : `,
        _Info,
    ]

    @parameter
    if Int(impl.num_captures) == -1:
        alias result = Info("", "", 0, _noop_populate, impl.asm, True)
        return result
    alias result = Info(
        impl.asm,
        get_linkage_name[target, func](),
        impl.num_captures,
        rebind[fn (UnsafePointer[NoneType]) capturing -> None](impl.populate),
        "",
        False,
    )
    return result


@always_inline
fn _compile_info_llvm_non_failable_impl[
    func_type: AnyTrivialRegType,
    func: func_type,
    /,
    target: __mlir_type.`!kgen.target` = _current_target(),
]() -> Info:
    alias cls = __mlir_attr[
        `#kgen.param.expr<compile_assembly,`,
        target,
        `,`,
        _EMISSION_KIND_LLVM,
        `,`,
        False.__mlir_i1__(),
        `,`,
        func,
        `> : `,
        _Info,
    ]

    constrained[Int(cls.num_captures) != -1, "failed to compile code"]()

    alias result = Info(
        cls.asm,
        get_linkage_name[target, func](),
        cls.num_captures,
        rebind[fn (UnsafePointer[NoneType]) capturing -> None](cls.populate),
        "",
        False,
    )
    return result


@always_inline
fn compile_info[
    func_type: AnyTrivialRegType, //,
    func: func_type,
    /,
    *,
    is_failable: Bool = False,
    emission_kind: StringLiteral = "asm",
    target: __mlir_type.`!kgen.target` = _current_target(),
]() -> Info:
    @parameter
    if emission_kind == "llvm":

        @parameter
        if is_failable:
            return _compile_info_llvm_failable_impl[
                func_type, func, target=target
            ]()
        else:
            return _compile_info_llvm_non_failable_impl[
                func_type, func, target=target
            ]()

    else:

        @parameter
        if is_failable:
            return _compile_info_asm_failable_impl[
                func_type, func, target=target
            ]()
        else:
            return _compile_info_asm_non_failable_impl[
                func_type, func, target=target
            ]()


# ===----------------------------------------------------------------------===#
# compile_code
# ===----------------------------------------------------------------------===#


fn compile_code[
    func_type: AnyTrivialRegType, //,
    func: func_type,
    /,
    *,
    emission_kind: StringLiteral = "asm",
    target: __mlir_type.`!kgen.target` = _current_target(),
]() -> StringLiteral:
    """Compiles the function passed in to the assembly instruction. This is
    useful to take a peak into the function assembly without requiring one to
    invoke kgen on a file."""
    alias info = compile_info[
        func, target=target, emission_kind=emission_kind
    ]()
    return info.asm
