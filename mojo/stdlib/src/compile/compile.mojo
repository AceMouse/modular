# ===----------------------------------------------------------------------=== #
#
# This file is Modular Inc proprietary.
#
# ===----------------------------------------------------------------------=== #
"""This module includes utilities for looking into the assembly of a specific
function. This is very useful for kernel engineers that do not want to look
at an entire file's assembly nor do they want to invoke the kgen tool manually.
"""

from os import PathLike
from pathlib import Path
from sys.info import _current_target

from memory import UnsafePointer

from utils import Writer

from .reflection import get_linkage_name

# ===-----------------------------------------------------------------------===#
# compile_info
# ===-----------------------------------------------------------------------===#


@value
@register_passable("trivial")
struct _Info:
    """A compiled closure implementation."""

    var asm: __mlir_type.`!kgen.string`
    var num_captures: __mlir_type.index


@value
@register_passable("trivial")
struct _PopulateInfo:
    """A compiled populate closure implementation.
    This struct matches the type of the compiled closure type generated by
    `compile_offload`.
    """

    var populate: fn (__mlir_type.`!kgen.pointer<none>`) capturing -> None


@value
@register_passable("trivial")
struct Info[func_type: AnyTrivialRegType, func: func_type]:
    var asm: StringLiteral
    var function_name: StringLiteral
    var module_name: StringLiteral
    var num_captures: Int
    alias populate = rebind[fn (UnsafePointer[NoneType]) capturing -> None](
        __mlir_attr[
            `#kgen.param.expr<compile_offload_closure,`,
            func,
            `> : `,
            _PopulateInfo,
        ].populate
    )
    var error_msg: StringLiteral
    var is_error: Bool

    @no_inline
    fn write_to[W: Writer](self, mut writer: W):
        return writer.write(self.asm)

    fn __str__(self) -> String:
        return String.write(self)

    @no_inline
    fn write_text[path_like: PathLike](self, path: path_like) raises:
        Path(path.__fspath__()).write_text(String(self))

    @no_inline
    fn __contains__(self, content: String) -> Bool:
        return content in String(self)


alias _EMISSION_KIND_ASM = 0
alias _EMISSION_KIND_LLVM = 1
alias _EMISSION_KIND_LLVM_OPT = 2
alias _EMISSION_KIND_OBJECT = 3


fn _get_emission_kind_id[emission_kind: StringLiteral]() -> IntLiteral:
    constrained[
        emission_kind in ("llvm", "llvm-opt", "object", "asm"),
        "invalid emission kind '" + emission_kind + "'",
    ]()

    @parameter
    if emission_kind == "llvm":
        return _EMISSION_KIND_LLVM
    elif emission_kind == "llvm-opt":
        return _EMISSION_KIND_LLVM_OPT
    elif emission_kind == "object":
        return _EMISSION_KIND_OBJECT
    else:
        return _EMISSION_KIND_ASM


fn _noop_populate(ptr: UnsafePointer[NoneType]) capturing:
    return


# (HACK, HACK, HACK), compile offload result is now a dynamic value
# instead of a compile time constant.
# The input of this function should not be treated as always
# a StringLiteral (compile time constant value).
# Mark this function as `always_inline` as a workaround to rely on
# compiler optimization to satisfy the input type requirement,
# but this is fragile.
@always_inline
fn _hash_module_name(s: StringLiteral) -> StringLiteral:
    return __mlir_op.`pop.string.hash`(s.value)


@always_inline
fn _compile_info_non_failable_impl[
    func_type: AnyTrivialRegType,
    func: func_type,
    /,
    emission_kind: IntLiteral,
    compile_options: StringLiteral,
    target: __mlir_type.`!kgen.target`,
]() -> Info[func_type, func]:
    var offload = __mlir_op.`kgen.compile_offload`[
        target_type=target,
        emission_kind = index(emission_kind),
        emission_option = compile_options.value,
        func=func,
        _type=_Info,
    ]()

    var result = Info[func_type, func] {
        asm: offload.asm,
        function_name: get_linkage_name[target, func](),
        module_name: _hash_module_name(offload.asm),
        num_captures: offload.num_captures,
        error_msg: "",
        is_error: False,
    }
    return result


@always_inline
fn compile_info[
    func_type: AnyTrivialRegType, //,
    func: func_type,
    /,
    *,
    emission_kind: StringLiteral = "asm",
    compile_options: StringLiteral = "",
    target: __mlir_type.`!kgen.target` = _current_target(),
]() -> Info[func_type, func]:
    return _compile_info_non_failable_impl[
        func_type,
        func,
        emission_kind = _get_emission_kind_id[emission_kind]().value,
        compile_options=compile_options,
        target=target,
    ]()


# ===-----------------------------------------------------------------------===#
# _internal_compile_code
# ===-----------------------------------------------------------------------===#


fn _internal_compile_code[
    func_type: AnyTrivialRegType, //,
    func: func_type,
    /,
    *,
    emission_kind: StringLiteral = "asm",
    compile_options: StringLiteral = "",
    target: __mlir_type.`!kgen.target` = _current_target(),
]() -> StringLiteral:
    """Compiles the function passed in to the assembly instruction. This is
    useful to take a peak into the function assembly without requiring one to
    invoke kgen on a file."""
    var info = compile_info[
        func,
        target=target,
        compile_options=compile_options,
        emission_kind=emission_kind,
    ]()
    return info.asm
