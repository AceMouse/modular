# ===----------------------------------------------------------------------=== #
#
# This file is Modular Inc proprietary.
#
# ===----------------------------------------------------------------------=== #
"""This module includes utilities for looking into the assembly of a specific
function. This is very useful for kernel engineers that do not want to look
at an entire file's assembly nor do they want to invoke the kgen tool manually.
"""

from os import PathLike
from pathlib import Path
from sys.info import _current_target

from memory import UnsafePointer

from utils import Writer

from .reflection import get_linkage_name

# ===----------------------------------------------------------------------===#
# compile_info
# ===----------------------------------------------------------------------===#


@value
@register_passable("trivial")
struct _Info:
    """A compiled closure implementation.

    This struct matches the type of the compiled closure type generated by
    `compile_assembly`.
    """

    var asm: __mlir_type.`!kgen.string`
    var num_captures: __mlir_type.index
    var populate: fn (__mlir_type.`!kgen.pointer<none>`) capturing -> None


@value
@register_passable("trivial")
struct Info:
    var asm: StringLiteral
    var function_name: StringLiteral
    var num_captures: Int
    var populate: fn (UnsafePointer[NoneType]) capturing -> None
    var error_msg: StringLiteral
    var is_error: Bool

    @no_inline
    fn write_to[W: Writer](self, inout writer: W):
        return writer.write(self.asm)

    fn __str__(self) -> String:
        return String.write(self)

    @no_inline
    fn write_text[path_like: PathLike](self, path: path_like) raises:
        Path(path.__fspath__()).write_text(str(self))

    @no_inline
    fn __contains__(self, content: String) -> Bool:
        return content in str(self)


alias _EMISSION_KIND_ASM = 0
alias _EMISSION_KIND_LLVM = 1
alias _EMISSION_KIND_LLVM_OPT = 2
alias _EMISSION_KIND_SHARED_OBJ = 3


fn _noop_populate(ptr: UnsafePointer[NoneType]) capturing:
    return


@always_inline
fn _compile_info_failable_impl[
    func_type: AnyTrivialRegType,
    func: func_type,
    /,
    emission_kind: IntLiteral,
    compile_options: StringLiteral,
    target: __mlir_type.`!kgen.target`,
]() -> Info:
    alias impl = __mlir_attr[
        `#kgen.param.expr<compile_assembly,`,
        target,
        `,`,
        emission_kind.__as_mlir_index(),
        `,`,
        compile_options.value,
        `,`,
        True.__mlir_i1__(),
        `,`,
        func,
        `> : `,
        _Info,
    ]

    @parameter
    if Int(impl.num_captures) == -1:
        alias result = Info {
            asm: "",
            function_name: "",
            num_captures: 0,
            populate: _noop_populate,
            error_msg: impl.asm,
            is_error: True,
        }
        return result
    alias result = Info {
        asm: impl.asm,
        function_name: get_linkage_name[target, func](),
        num_captures: impl.num_captures,
        populate: rebind[fn (UnsafePointer[NoneType]) capturing -> None](
            impl.populate
        ),
        error_msg: "",
        is_error: False,
    }
    return result


@always_inline
fn _compile_info_non_failable_impl[
    func_type: AnyTrivialRegType,
    func: func_type,
    /,
    emission_kind: IntLiteral,
    compile_options: StringLiteral,
    target: __mlir_type.`!kgen.target`,
]() -> Info:
    alias cls = __mlir_attr[
        `#kgen.param.expr<compile_assembly,`,
        target,
        `,`,
        emission_kind.__as_mlir_index(),
        `,`,
        compile_options.value,
        `,`,
        False.__mlir_i1__(),
        `,`,
        func,
        `> : `,
        _Info,
    ]

    constrained[Int(cls.num_captures) != -1, "failed to compile code"]()

    alias result = Info {
        asm: cls.asm,
        function_name: get_linkage_name[target, func](),
        num_captures: cls.num_captures,
        populate: rebind[fn (UnsafePointer[NoneType]) capturing -> None](
            cls.populate
        ),
        error_msg: "",
        is_error: False,
    }
    return result


@always_inline
fn compile_info[
    func_type: AnyTrivialRegType, //,
    func: func_type,
    /,
    *,
    is_failable: Bool = False,
    emission_kind: StringLiteral = "asm",
    compile_options: StringLiteral = "",
    target: __mlir_type.`!kgen.target` = _current_target(),
]() -> Info:
    @parameter
    if emission_kind == "llvm":

        @parameter
        if is_failable:
            return _compile_info_failable_impl[
                func_type,
                func,
                emission_kind=_EMISSION_KIND_LLVM,
                compile_options=compile_options,
                target=target,
            ]()
        else:
            return _compile_info_non_failable_impl[
                func_type,
                func,
                emission_kind=_EMISSION_KIND_LLVM,
                compile_options=compile_options,
                target=target,
            ]()

    @parameter
    if emission_kind == "llvm-opt":

        @parameter
        if is_failable:
            return _compile_info_failable_impl[
                func_type,
                func,
                emission_kind=_EMISSION_KIND_LLVM_OPT,
                compile_options=compile_options,
                target=target,
            ]()
        else:
            return _compile_info_non_failable_impl[
                func_type,
                func,
                emission_kind=_EMISSION_KIND_LLVM_OPT,
                compile_options=compile_options,
                target=target,
            ]()

    @parameter
    if emission_kind == "shared-obj":

        @parameter
        if is_failable:
            return _compile_info_failable_impl[
                func_type,
                func,
                emission_kind=_EMISSION_KIND_SHARED_OBJ,
                compile_options=compile_options,
                target=target,
            ]()
        else:
            return _compile_info_non_failable_impl[
                func_type,
                func,
                emission_kind=_EMISSION_KIND_SHARED_OBJ,
                compile_options=compile_options,
                target=target,
            ]()

    else:

        @parameter
        if is_failable:
            return _compile_info_failable_impl[
                func_type,
                func,
                emission_kind=_EMISSION_KIND_ASM,
                compile_options=compile_options,
                target=target,
            ]()
        else:
            return _compile_info_non_failable_impl[
                func_type,
                func,
                emission_kind=_EMISSION_KIND_ASM,
                compile_options=compile_options,
                target=target,
            ]()


# ===----------------------------------------------------------------------===#
# _internal_compile_code
# ===----------------------------------------------------------------------===#


fn _internal_compile_code[
    func_type: AnyTrivialRegType, //,
    func: func_type,
    /,
    *,
    emission_kind: StringLiteral = "asm",
    compile_options: StringLiteral = "",
    target: __mlir_type.`!kgen.target` = _current_target(),
]() -> StringLiteral:
    """Compiles the function passed in to the assembly instruction. This is
    useful to take a peak into the function assembly without requiring one to
    invoke kgen on a file."""
    alias info = compile_info[
        func,
        target=target,
        compile_options=compile_options,
        emission_kind=emission_kind,
    ]()
    return info.asm
